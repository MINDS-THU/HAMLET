"""
The problem is to simulate Miller Construction Company’s bidding decision using a Monte Carlo approach. Miller faces uncertainty in two cost items: the cost to prepare a bid and the cost to complete the project; both follow a triangular distribution. In addition, there are four potential competitors; each competes with probability 0.5, and if they bid, their bid is generated by a triangular distribution (multiplier of Miller’s most likely complete project cost). For each candidate bid (ranging from $10,500 to $15,000 in $500 increments), we simulate many trials. In each trial we: 
1. Generate Miller’s cost to prepare a bid and cost to complete the project via triangular distributions with the provided parameters. 
2. Determine the number of competitors bidding by drawing from a binomial distribution (n = 4, p = 0.5). 
3. For each bidding competitor, if any, generate a bid by multiplying a triangular sample (min=0.9, mode=1.3, max=1.8) by 10,000 (Miller’s most likely cost to complete the project). 
4. Determine if Miller wins the bid. Miller wins if there are no competitor bids or if Miller’s bid is lower than the minimum competitor bid. 
5. Compute profit as the bid amount minus the completion cost (if win) or simply incur the bid preparation cost (if loss). 
6. Record the “win” indicator and profit for that simulation. 
After running a large number of iterations (e.g., 10,000) for each candidate bid, we compute summary statistics (min, mean, max, median, standard deviation, 0.05 quantile, 0.95 quantile) for both the Wins Bid indicator and Profit. These outputs mimic the produced results in the Excel file’s Output Results tab.
The Python code below implements this approach using standard libraries like numpy and random, and prints out the computed summary statistics for each candidate bid.
"""

#!/usr/bin/env python3
"""
Monte Carlo Simulation for Miller Construction Company's bidding decision.
Simulates the cost to prepare bid and cost to complete project using triangular distributions,
competitor bids using a binomial model and triangular multipliers, and computes profit at each
candidate bid amount (from 10500 to 15000 in increments of 500).
"""

import numpy as np
import random

# Set random seed for reproducibility
# random.seed(42)
# np.random.seed(42)

# Simulation parameters
NUM_SIMULATIONS = 10000

# Miller's cost parameters (triangular distributions)
# Cost to prepare bid: min, mode, max
prep_bid_min = 300
prep_bid_mode = 350
prep_bid_max = 500

# Cost to complete project: min, mode, max
comp_cost_min = 9000
comp_cost_mode = 10000
comp_cost_max = 15000

# Competitor parameters
num_competitors = 4
competitor_bid_prob = 0.5
# Triangular parameters for competitor bid multiplier
comp_mult_min = 0.9
comp_mult_mode = 1.3
comp_mult_max = 1.8

# Miller's candidate bid amounts (from 10500 to 15000, increments of 500)
candidate_bids = list(range(10500, 15000 + 1, 500))

# Miller's most likely cost to complete project is used for competitor bid calculation
# (per the Excel model, competitor bid multiplier is applied to the "most likely" cost)
miller_most_likely_cost = comp_cost_mode


def simulate_trial(m_bid):
    """
    Simulate one trial for a given Miller bid amount (m_bid).
    Returns: tuple (win, profit) for that trial
    """
    # Generate Miller's costs using triangular distribution
    # random.triangular expects (low, mode, high)
    cost_prep = np.random.triangular(prep_bid_min, prep_bid_mode, prep_bid_max)
    cost_complete = np.random.triangular(comp_cost_min, comp_cost_mode, comp_cost_max)

    # Determine number of competitor bids - using binomial(n, p)
    num_bids = np.random.binomial(num_competitors, competitor_bid_prob)

    competitor_bids = []
    if num_bids > 0:
        for i in range(num_bids):
            # Competitor bid is multiplier * miller_most_likely_cost
            multiplier = np.random.triangular(comp_mult_min, comp_mult_mode, comp_mult_max)
            bid_value = multiplier * miller_most_likely_cost
            competitor_bids.append(bid_value)

    # Determine if Miller wins the bid
    # Miller wins if no competitors or if its bid is lower than the minimum competitor bid
    if num_bids == 0 or m_bid < min(competitor_bids):
        win = 1
        profit = (m_bid - cost_complete) - cost_prep
    else:
        win = 0
        profit = - cost_prep

    return win, profit

def print_summary(results):
    header = f"{'Bid':>6} | {'Wins (min,mean,max,median,std,0.05,0.95)':>45} | {'Profit (min,mean,max,median,std,0.05,0.95)':>55}"
    print(header)
    print('-' * len(header))
    for bid in sorted(results.keys()):
        w = results[bid]['Wins']
        p = results[bid]['Profit']
        wins_summary = f"{w['min']:.0f},{w['mean']:.3f},{w['max']:.0f},{w['median']:.0f},{w['std']:.3f},{w['0.05_quantile']:.0f},{w['0.95_quantile']:.0f}"
        profit_summary = f"{p['min']:.2f},{p['mean']:.2f},{p['max']:.2f},{p['median']:.2f},{p['std']:.2f},{p['0.05_quantile']:.2f},{p['0.95_quantile']:.2f}"
        print(f"{bid:6d} | {wins_summary:45s} | {profit_summary:55s}")

def run_simulation():
    res = {}
    results = {}
    for bid in candidate_bids:
        wins = []
        profits = []
        for _ in range(NUM_SIMULATIONS):
            win, profit = simulate_trial(bid)
            wins.append(win)
            profits.append(profit)
        wins = np.array(wins)
        profits = np.array(profits)

        # Calculate summary statistics
        stats = {
            'bid': bid,
            'Wins': {
                'min': float(np.min(wins)),
                'mean': float(np.mean(wins)),
                'max': float(np.max(wins)),
                'median': float(np.median(wins)),
                'std': float(np.std(wins)),
                '0.05_quantile': float(np.quantile(wins, 0.05)),
                '0.95_quantile': float(np.quantile(wins, 0.95))
            },
            'Profit': {
                'min': float(np.min(profits)),
                'mean': float(np.mean(profits)),
                'max': float(np.max(profits)),
                'median': float(np.median(profits)),
                'std': float(np.std(profits)),
                '0.05_quantile': float(np.quantile(profits, 0.05)),
                '0.95_quantile': float(np.quantile(profits, 0.95))
            }
        }
        results[bid] = stats
        res[f"wins for bidding {bid}"] = wins
        res[f"profits for bidding {bid}"] = profits
        # res.append([float(np.mean(wins)), float(np.std(wins))])
        # res.append([float(np.mean(profits)), float(np.std(profits))])

    print_summary(results)
    return res



if __name__ == '__main__':
    simulation_results = run_simulation()
    print(simulation_results)
    
